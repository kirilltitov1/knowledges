## REST vs gRPC vs GraphQL — как выбрать на iOS

### TL;DR
- Если «обычное приложение» с CRUD‑бэкендом → **REST + JSON**.
- Если нужна скорость/компактность и стримы → **gRPC + Protobuf**.
- Если экраны требуют гибких выборок разных доменов → **GraphQL**.

### Что важно мобильному клиенту
- Латентность и размер ответа, предсказуемость схем, стабильность контрактов.
- Кэшируемость (особенно для списков/каталогов), простота ретраев и идемпотентности.
- Диагностируемость в полях: трассировка, коды ошибок, совместимость версий.

### Сравнение
| Критерий | REST | gRPC | GraphQL |
|---|---|---|---|
| Транспорт | HTTP/1.1/2 | HTTP/2 | HTTP/1.1/2 |
| Формат | JSON | Protobuf | JSON |
| Гибкость выборок | Низкая | Средняя (контракты RPC) | Высокая |
| Производительность | Средняя | Высокая | Средняя |
| Стриминг | Ограниченно | Полноценный (bidi) | Через subscriptions (вебсокеты) |
| Кэширование | Природное (HTTP кеш) | На уровне клиента | Сложнее, нормализующий кеш |
| Инструменты iOS | `URLSession`, `Codable` | gRPC‑Swift, SwiftProtobuf | Apollo iOS |

### Паттерны интеграции
- REST: версионирование `/v1`, ETag/Last‑Modified, пагинация (page/cursor), четкие коды ошибок.
- gRPC: codegen, явные таймауты, лимиты сообщений, маппинг статусов в доменные ошибки.
- GraphQL: схемы и фрагменты, нормализующий кеш, политика обновления, error‑policy.

### Комбинирование
Часто сочетают: REST для «широких» публичных API, gRPC для внутренних/высоконагруженных путей, GraphQL для агрегированных экранов; realtime — через WebSocket.

См. также: [protocols-and-data-formats.md](protocols-and-data-formats.md), [rest-api.md](rest-api.md), [grpc.md](grpc.md), [graphql.md](graphql.md)


