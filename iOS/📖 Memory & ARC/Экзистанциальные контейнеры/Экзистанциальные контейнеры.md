---
title: Экзистанциальные контейнеры
type: thread
topics:
  - Memory & ARC
subtopic: Экзистанциальные контейнеры
status: draft
---
# Экзистенциальные контейнеры в Swift — финальный краткий гайд

> Цель: коротко, без воды, но полно. Размеры — для 64-бит и «типично» (ABI может отличаться → проверяйте `MemoryLayout`).

---

## 0) Термины

- **`Any`** — верхний тип (opaque existential), **нет** требований протокола.
    
- **`any P`** — экзистенциал протокола `P`.
    
- **Class-bound** — `any P & AnyObject` или `protocol P: AnyObject`.
    
- **Witness-table** — таблица реализаций требований протокола.
    
- **Inline-буфер** — встроенные ~3 машинных слова под полезные данные.
    

---

## 1) Формы контейнера (их ровно 3)

| Форма                               | Макет в памяти                        | Типичный размер | Комментарий                                                |
| ----------------------------------- | ------------------------------------- | --------------: | ---------------------------------------------------------- |
| **`Any`**                           | `[ buffer ×3 ][ type ]`               | ~32 B (4 слова) | Нет witness-таблиц. Буфер всегда есть.                     |
| **`any P`**                         | `[ buffer ×3 ][ type ][ witness(P) ]` |  ~40 B (5 слов) | +8 B за **каждый** доп. протокол: `any P & Q`→ +1 witness. |
| **Class-bound** `any P & AnyObject` | `[ object ptr ][ witness(P) ]`        | ~16 B (2 слова) | **Буфера нет.** `& AnyObject` не даёт +8: это не протокол. |
| **`any AnyObject`**                 | `[ object ptr ]`                      |  ~8 B (1 слово) | Только указатель на объект.                                |
|                                     |                                       |                 |                                                            |

**Важно:** Различие форм определяется **ограничениями протокола**, а не тем, value это или reference.

---

## 2) Что лежит «внутри» буфера

### Для форм с буфером (`Any`, `any P`):

- **Маленькая `struct`** (≤3 слов) → **inline** в буфере.
    
- **Большая/ресилентная `struct`** → **box** в heap, в буфере — **указатель на box**.
    
- **Класс** (`UIView`) → в буфере **указатель на объект** (никакого дополнительного бокса экзистенциалом не создаётся).
    

### Для class-bound форм (`any P & AnyObject`, `any AnyObject`):

- **Буфера нет**: хранится только указатель на объект (+ witness-ы для реальных протоколов).
    

---

## 3) Вызовы методов

- `any …` вызывается через **witness-таблицу(ы)** → динамическая диспетчеризация, дороже дженериков.
    
- `Any` не содержит требований → witness-таблиц нет.
    

---

## 4) PAT (`associatedtype`/`Self`)

- Нельзя «голый» `any Sequence`. Нужно:
    
    - **Зафиксировать** ассоц. тип: `typealias AnyIntBag = any Bag<Int>`
        
    - или **type-erasure** (`AnySequence`, `AnyPublisher`, свой `Any…`).
        

---

## 5) Многопротокольные экзистенциалы

- Каждый дополнительный протокол добавляет **+1 указатель на witness** (~8 B).
    
    - `any P & Q` (без `AnyObject`) → ~48 B.
        
    - `any P & Q & AnyObject` → объект + 2 witness → ~24 B.
        

---

## 6) Быстрые примеры (для заметок/Playground)

```swift
protocol P { func f() }
protocol Q { func g() }
protocol COnly: AnyObject { func h() }

struct S24: P { var a:Int64=0,b:Int64=0,c:Int64=0; func f(){} } // ~24B
struct S32: P { var t=(Int64(0),Int64(0),Int64(0),Int64(0)); func f(){} } // >24B
final class K: P, Q, COnly { func f(){}; func g(){}; func h(){} }

// Размеры форм
MemoryLayout<Any>.size                   // ~32
MemoryLayout<any P>.size                 // ~40
MemoryLayout<any P & Q>.size             // ~48
MemoryLayout<any P & AnyObject>.size     // ~16
MemoryLayout<any AnyObject>.size         // ~8

// Поведение буфера
let a: Any = 42          // inline
let b: Any = "2012"      // value-репрезентация укладывается в буфер
let c: Any = UIView()    // buffer.word0 = &UIView-instance (объект в heap)
let d: any P = S32()     // большой struct → box в heap, в буфере указатель на box
let e: any P & AnyObject = K() // [object ptr][witness], буфера нет

// Гетерогенный массив
let mixed: [Any] = [42, "2012", UIView()] // каждый элемент — контейнер Any (~32B)
```

---

## 7) Частые ответы (1 строка)

- **Почему `any P & AnyObject` = 16 B?** Объект + 1 witness; метаданные из объекта; **буфера нет**.
    
- **`& AnyObject` добавляет +8?** Нет. Это **ограничение**, а не протокол.
    
- **В `[Any]` где живёт `UIView()`?** Объект в heap, в буфере `Any` лежит **указатель** на него.
    
- **Почему `Any` толще `any AnyObject`?** У `Any` есть буфер + метаданные (4 слова), у `any AnyObject` — только указатель (1 слово).
    
- **Когда боксится `struct`?** Когда не влазит в 3 слова / размер не известен в текущем resilience-домене.
    

---

## 8) Как выбирать

- **Гетерогенность нужна** → `Any` / `any …` (осознавая накладные расходы).
    
- **Горячий путь/производительность** → дженерики `<T: P>` или `some P`.
    
- **Все значения — классы** → добавьте `& AnyObject` (компактно).
    
- **PAT** → фиксируйте ассоц. типы или используйте type-erasure.
    

---

## 9) Мини type-erasure шаблон

```swift
protocol Sink {
    associatedtype Input
    mutating func send(_ value: Input)
}

struct AnySink<Input>: Sink {
    private var _send: (Input) -> Void
    init<S: Sink>(_ base: S) where S.Input == Input {
        var copy = base
        _send = { copy.send($0) }
    }
    mutating func send(_ value: Input) { _send(value) }
}
```

---

## 10) Памятка-чеклист

- Формы: **`Any`**, **`any P`**, **class-bound** (`any P & AnyObject` / `any AnyObject`).
    
- Буфер есть **только** у `Any` и `any P`; у class-bound его **нет**.
    
- Для класса в формах с буфером в буфер кладётся **указатель на объект**.
    
- Каждый доп. протокол = **+8 B** (witness).
    
- Проверяйте размеры на целевой платформе: `MemoryLayout<T>.size`.
    

Если хочешь, могу упаковать это в один printable Markdown-лист для Obsidian (с заголовками и кодом как здесь).