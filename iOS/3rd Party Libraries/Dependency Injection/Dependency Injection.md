---
type: "thread"
topics:
  - Users
  - kirilltitov
  - DocumentsUsers", "kirilltitov", "Documents"]"
status: "draft"
summary: ""
title: "Dependency Injection"
---

# Dependency Injection — Гайд по выбору (iOS)

Этот документ помогает быстро выбрать подход к DI и конкретную библиотеку под задачи проекта и вопросы system design интервью.

## Когда DI без библиотеки (Manual DI)

- **Малые приложения/прототипы**: инжекция через конструкторы, композиционный корень в `App`/координаторе.
- **Требования к простоте/прозрачности**: максимум compile-time гарантий без сторонних зависимостей.
- **Минусы**: больше ручного кода в крупных проектах, сложнее поддерживать области жизни и переопределения в тестах.

## Когда DI с библиотекой

- **Нужны области жизни** (singleton/container, graph/screen, transient/weak).
- **Модульность и масштабируемость**: фичи как `Assembly`/компоненты, переиспользование конфигураций.
- **Тестопригодность**: удобные подмены реализаций и отдельные контейнеры на тест.
- **Интеграции**: Storyboard, SwiftUI property wrappers, авто-регистрация, codegen.

## Ключевые критерии выбора

- **Безопасность**: compile-time (Needle, Cleanse, Manual) vs runtime-проверки (Swinject, Resolver, Factory).
- **Перфоманс**: статически сгенерированный код обычно быстрее и предсказуемее на старте.
- **Эргономика/скорость внедрения**: property wrappers, автозаполнение, простота API.
- **Модульность**: наличие `Assembly`/компонентов и поддержка multi-module.
- **Интеграции**: SwiftUI, UIKit Storyboard, аргументы при резолюции, авто-регистрация.
- **Порог входа/поддержка**: требуются ли скрипты генерации, конфигурация CI, документация.

## Библиотеки: плюсы и минусы

### Swinject (runtime контейнер)
- **Плюсы**:
  - Богатая модель областей жизни: `.container`, `.graph`, `.transient`, `.weak`.
  - `Assembly/Assembler` для модульности; `SwinjectStoryboard` для UIKit.
  - Авто-регистрация (отдельный пакет), аргументы при резолюции, синхронизированный резолвер.
  - Зрелая экосистема, понятный порог входа.
- **Минусы**:
  - Проверки в рантайме: ошибки резолюции — во время выполнения.
  - Нет официальных SwiftUI wrappers (нужна тонкая обертка под `Environment`).

### Resolver (runtime контейнер)
- **Плюсы**:
  - Удобные `@Injected/@LazyInjected` property wrappers, отличная интеграция со SwiftUI.
  - Простая регистрация и области `.application/.shared/.cached/.unique`.
  - Низкий порог входа, быстрый старт.
- **Минусы**:
  - Рантайм-проверки; меньше гибкости по Storyboard/аргументам, чем у Swinject.

### Factory (runtime контейнер)
- **Плюсы**:
  - Минималистичный синтаксис с `Factory<T>` и `@Injected`, ориентирован на SwiftUI.
  - Прозрачная конфигурация через `Container`-расширения; хороший DX.
- **Минусы**:
  - Рантайм-проверки; меньше возможностей по сравнению с крупными контейнерами.

### Needle (compile-time, Uber)
- **Плюсы**:
  - Compile-time гарантии через генерацию кода; минимальный рантайм overhead.
  - Четкая модульность: компоненты/протоколы/скоупы.
- **Минусы**:
  - Выше порог входа; требуется настройка генерации, поддержка структуры проекта.
  - Менее гибок для быстрых прототипов и частых архитектурных изменений.

### Cleanse (compile-time, Square)
- **Плюсы**:
  - Декларативная модульная конфигурация; compile-time проверки.
  - Хорош для крупных проектов и строгих контрактов зависимостей.
- **Минусы**:
  - Сложнее освоение и конфигурация; дополнительный бойлерплейт.

### Manual DI
- **Плюсы**: максимум предсказуемости и compile-time гарантий, отсутствие внешних зависимостей.
- **Минусы**: рост ручного кода с масштабом, сложнее поддерживать сложные скоупы и переопределения.

## Сравнительная таблица

| Библиотека | Тип               | Безопасность     | Перфоманс     | Области жизни                           | SwiftUI                | Storyboard              | Autoreg    | Порог входа    |
| ---------- | ----------------- | ---------------- | ------------- | --------------------------------------- | ---------------------- | ----------------------- | ---------- | -------------- |
| Swinject   | Рантайм-контейнер | Рантайм-проверки | Высокая       | Да (.container/.graph/.transient/.weak) | Через обертки          | Да (SwinjectStoryboard) | Да (пакет) | Средний        |
| Resolver   | Рантайм-контейнер | Рантайм-проверки | Высокая       | Да                                      | Да (property wrappers) | Нет                     | Нет        | Низкий         |
| Needle     | Codegen           | Компайл-тайм     | Очень высокая | Да                                      | Опционально            | Нет                     | Нет        | Выше среднего  |
| Cleanse    | Codegen/модули    | Компайл-тайм     | Очень высокая | Да                                      | Опционально            | Нет                     | Нет        | Высокий        |
| Factory    | Рантайм-контейнер | Рантайм-проверки | Высокая       | Да                                      | Да (property wrappers) | Нет                     | Нет        | Низкий         |
| Manual DI  | Без контейнера    | Компайл-тайм     | Очень высокая | Ручное                                  | Да                     | Да                      | —          | Низкий/Средний |

## Рекомендации по сценариям

- **Greenfield (SwiftUI-first, быстрый старт)**: Resolver или Factory. Быстрые property wrappers, минимум конфигурации.
- **Greenfield (UIKit/Storyboard, модульность)**: Swinject (+ `SwinjectStoryboard`, `Assemblies`).
- **Legacy/миграция по частям**: Swinject — добавляйте `Assembly` по фичам, постепенно вытесняя синглтоны.
- **Multi-module/монорепо, строгие гарантии**: Needle или Cleanse для compile-time безопасности.
- **SDK/библиотека для внешних клиентов**: Manual DI или Needle (минимум рантайм-магии, явные контракты).
- **Высоконагруженные холодные старты**: Needle/Cleanse (меньше рантайм конфигов), либо Swinject с предрегистрацией на старте.

## На что обратить внимание в дизайне

- **Композиционный корень**: вся регистрация — на старте приложения/модуля, не в домене.
- **Конструкторная инъекция**: предпочтительнее property-инъекции; легче тестировать.
- **Скоупы**: не злоупотребляйте синглтонами; используйте `.graph`/экранные скоупы.
- **Тесты**: отдельные контейнеры/резолверы для изоляции, переопределения регистраций в тестах.
- **Антипаттерны**: service locator, регистрация на лету, глубокая резолюция в домене.

## Типовые ответы для system design интервью

- **Как выбрать DI-подход?** Начинаю с Manual DI для простоты и compile-time гарантий. При росте — перехожу на контейнер (Swinject/Resolver) для областей жизни и модульности. Для критичных гарантий и больших команд — Needle/Cleanse.
- **Как организовать модульность?** Разделяю конфигурацию по фичам (`Assembly`/компоненты). Корневой сборщик агрегирует их. На тестах — отдельный контейнер.
- **Как избежать service locator?** Инжектирую зависимости на границах модулей/вью-моделей, не запрашиваю из контейнера глубоко в домене.
- **Как работать со SwiftUI?** Использую property wrappers (Resolver/Factory) или тонкую обертку вокруг Swinject через `Environment`.
- **Что с производительностью?** Предрегистрация на старте, синхронизированный резолвер при многопоточности, compile-time подходы для минимизации рантайм overhead.


