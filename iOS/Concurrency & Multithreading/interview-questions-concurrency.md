---
type: "thread"
status: "draft"
title: "Вопросы для собеседований: Конкурентность и многопоточность"
subtopic: "Интервью"
---

# Вопросы для собеседований: Конкурентность и многопоточность

## База
1. Concurrency vs Parallelism — различия, примеры на iOS.
2. Что такое data race? Способы предотвращения.
3. Deadlock/Livelock/Starvation/Priority inversion — определения и примеры.
4. Зачем нужны QoS? Как выбирать.
5. Почему UI только на main? Роль MainActor.

## GCD
6. Разница sync/async, serial/concurrent.
7. Что такое DispatchGroup и как им пользоваться?
8. Зачем нужен barrier?
9. Когда применять семафор?

## Operations
10. Преимущества Operation над GCD.
11. Как реализовать корректную AsyncOperation?
12. Как работают зависимости и отмена?

## Swift Concurrency
13. Structured concurrency, Task/TaskGroup.
14. Difference Task vs Task.detached.
15. Actors и изоляция состояния.
16. Sendable и потоко‑безопасные типы.
17. Bridging callback → async через continuations.
18. Обработка отмены и ошибок.

## Практика
19. Ограничьте параллелизм до N.
20. Спроектируйте pipeline: сеть → парсинг → кэш → UI.
21. Найдите и исправьте deadlock в примере.
22. Реализуйте readers-writer кэш.
23. Напишите `AsyncSequence` для событий.


## Q/A (без ссылок)

1) В чём разница между concurrency и parallelism?
- Concurrency — одновременное управление несколькими задачами; Parallelism — одновременное выполнение на нескольких ядрах.

2) Что такое data race и как предотвратить?
- Несогласованный доступ к общему изменяемому состоянию. Решения: акторы, локи/барьеры, сериализация доступа, неизменяемые структуры данных.

3) Что такое deadlock и как его избежать?
- Взаимная блокировка. Не вызывайте `sync` на той же очереди и `DispatchQueue.main.sync` из main; упрощайте граф зависимостей.

4) Для чего нужны уровни QoS?
- Соотнести важность работы с UX и энергопотреблением. UI‑критичное — `userInteractive`, не срочное — `utility/background`.

5) Почему UI только на main?
- UI‑фреймворки не потокобезопасны. Используйте `@MainActor`/`DispatchQueue.main.async`.

6) Serial vs Concurrent?
- Serial обеспечивает порядок, Concurrent даёт параллелизм при наличии ресурсов.

7) sync vs async?
- sync блокирует вызывающий поток; async — нет.

8) Для чего DispatchGroup?
- Ожидать завершение набора задач, делать fan‑in без блокировки UI (через `notify`).

9) Что делает barrier?
- Обеспечивает эксклюзивную запись на конкурентной очереди (readers‑writer).

10) Когда использовать семафор?
- Для ограничения параллелизма/доступа к ресурсу. Избегайте deadlock, освобождайте сигналы гарантированно (`defer`).

11) Зачем OperationQueue?
- Зависимости, приоритеты, отмена, переиспользуемые операции и оркестрация.

12) Как правильно написать AsyncOperation?
- Корректные KVO `isExecuting/isFinished`, потокобезопасные флаги, быстрая реакция на `isCancelled`.

13) Зачем Swift Concurrency?
- Читаемость, структурированная конкурентность, акторы и безопасность по умолчанию.

14) `Task {}` vs `Task.detached`?
- Detached не наследует приоритет/отмену/actor‑контекст. Предпочитайте `Task {}`.

15) Когда использовать TaskGroup?
- Для параллельной обработки набора независимых задач с автоматической отменой и сбором результатов.

16) Что дают акторы?
- Сериализованный доступ к состоянию без ручных локов.

17) Что такое Sendable?
- Гарантия, что тип безопасно передаётся между изоляциями/потоками.

18) Для чего continuations?
- Мост от callback‑стиля к async/await. Важно вызывать `resume` ровно один раз.

19) Что такое AsyncSequence?
- Асинхронный поток значений (итерация через `for await`). Удобно для событий.

20) Как правильно обрабатывать отмену?
- Регулярно проверять `Task.isCancelled`/`Task.checkCancellation()` и выполнять cleanup в `withTaskCancellationHandler`.

21) Как ограничить параллелизм?
- Семафоры, `maxConcurrentOperationCount`, батчинг задач.

22) Как проектировать readers‑writer кэш?
- Конкурентные чтения, записи через barrier или актор.

23) Как избежать thread explosion?
- Ограничивайте параллелизм, переиспользуйте очереди, измеряйте нагрузку.

24) Как не блокировать main?
- Не выполнять тяжёлое на `@MainActor`; переносите на фон и возвращайтесь на main только для UI.

25) Что такое reentrancy у акторов?
- Между `await` возможен повторный вход; инварианты состояния не должны нарушаться.

26) Как тестировать async код?
- XCTest с `async`/`await` или `XCTestExpectation` для легаси. Делайте тесты детерминированными.

27) Чем TaskGroup лучше DispatchGroup?
- Типобезопасность, автоматическая отмена, интеграция с `throw`.

28) Как реализовать таймаут задачи?
- Обёртка через задачу‑сторож (`Task.sleep`) и отмена, либо конкурентная гонка результатов.

29) Что такое `TaskLocal`?
- Локальные значения задачи для передачи контекста (например, requestId) по иерархии задач.

30) Когда использовать Threads напрямую?
- Редко: специализированные сценарии/RunLoop‑требования/низкоуровневые интеграции.

31) Что делать с тяжёлыми CPU-задачами?
- Выносить на фоновые очереди/исполнители, не блокировать main, разбивать на батчи.

32) Как минимизировать executor hops?
- Группируйте UI‑обновления, используйте один контекст исполнения для связанных операций.

33) Какой стратегией ограничить N параллельных задач в async?
- Вести счётчик/семафор, запускать задачи батчами или пулом фиксированного размера.

34) Как безопасно читать/писать общий кэш?
- Readers — конкурентно, writers — эксклюзивно (barrier) или актор.

35) Как проектировать пайплайн сеть→парсинг→кэш→UI?
- TaskGroup для параллельных стадий, данные — в кэш, UI — на main.

36) Что такое starvation и как его избегать?
- Низкоприоритетные задачи не получают квант. Баланс QoS и ограничение долгих высокоприоритетных задач.

37) Как избежать livelock?
- Экспоненциальный backoff, рандомизация, лимит ретраев.

38) Чем плохи большие критические секции?
- Ухудшают масштабирование, растёт ожидание. Делите на мелкие атомы.

39) Как правильно использовать `autoreleasepool`?
- Оборачивать тело больших циклов, чтобы быстрее освобождать временные объекты.

40) Можно ли вызывать UI из фоновой очереди?
- Нет. Переключитесь на main (`@MainActor` или `DispatchQueue.main.async`).

41) Как обрабатывать ошибки при параллельной загрузке нескольких ресурсов?
- `withThrowingTaskGroup`: первая ошибка отменяет оставшиеся; агрегируйте результаты.

42) Что делать, если часть задач должна игнорировать отмену?
- Явно игнорируйте `isCancelled` в критической секции и завершайте безопасно после.

43) Как протестировать гонки данных?
- Включить Thread Sanitizer, запускать конкурирующие операции многократно, проверять инварианты.

44) Как дебажить async стек вызовов?
- Сборка -Onone, LLDB `bt`, Concurrency Debugger, именование задач.

45) Что такое `Task.yield()`?
- Добровольная передача квантa планировщику; полезно для кооперативности.

46) Когда использовать `Task.detached`?
- Редко: полностью изолированные работы без родительского контекста/приоритета.

47) Как защитить доступ к mutable массиву из нескольких потоков?
- Актор/serial очередь/барьерная запись.

48) Почему `@unchecked Sendable` опасен?
- Отключает проверку безопасности; легко спрятать гонки.

49) Как хранить контекст запроса глубоко в стеке async?
- Task‑local значения (`@TaskLocal`).

50) Чем Actor отличается от изолированного `DispatchQueue`?
- Языковая изоляция, интеграция с `await`, проверка `Sendable`, меньше ручной синхронизации.

51) Можно ли вызвать `await` внутри `@MainActor` тяжёлой работы?
- Не стоит: вынесите тяжёлое на фон и вернитесь на main для UI.

52) Как выполнять периодическую работу без RunLoop?
- `DispatchSourceTimer` или `Timer` на run loop соответствующего потока.

53) Чем отличается `async let` от TaskGroup?
- `async let` для фиксированного малого числа параллельных работ; TaskGroup — динамические наборы/циклы.

54) Как правильно завершать `AsyncOperation`?
- Вызывать `finish()` с корректными KVO переходами и учётом отмены.

55) Когда использовать Operation dependencies?
- При явных графах и порядке, невозможном через простой `await`.

56) Что такое back-pressure и как его реализовать?
- Контроль притока задач: очереди с лимитом, семафоры, батч размер, политика ретраев.

57) Как писать код, устойчивый к отмене?
- Часто проверять отмену, иметь cleanup, проектировать идемпотентность.

58) Как избежать дедлока при использовании локов?
- Согласованный порядок захвата, избегать вложенных локов, использовать R/W‑локи.

59) Зачем `nonisolated` методам акторов?
- Публичные операции без доступа к состоянию, вызываются без `await`.

60) Можно ли делиться объектами между акторами?
- Да, если они `Sendable` или иммутабельны; избегайте совместного mutable состояния.

61) Как обновить несколько свойств UI эффективно?
- Группируйте в один `MainActor.run`/обновление ViewModel, чтобы сократить hops.

62) Как грамотно выбрать размер пула параллелизма?
- Эмпирически, ориентируясь на CPU/IO природу задач и лимиты сервиса.

63) Когда использовать `withUnsafeContinuation`?
- Только при отсутствии альтернатив, с аккуратной гарантией ровно одного `resume`.

64) Как обеспечить упорядоченную обработку событий?
- Serial очередь/актор, или нумерация/буферизация и последующая сортировка.

65) Как сделать отменяемую загрузку изображений в списке?
- Хранить `Task` на ячейку/модель, `cancel()` при реюзе/скролле, кооперативная отмена внутри.

66) Что делать с тяжёлыми JSON‑парсами?
- Выполнять на фоне, декодировать потоково при больших данных, использовать батчи.

67) Как защититься от priority inversion?
- Корректные QoS, короткие критические секции, по возможности акторы.

68) Почему важно измерять, а не гадать?
- Конкурентность сложно предсказуема; профилирование показывает реальные узкие места.

69) Как отделить UI и фоновые слои?
- Чёткие API: фоновые сервисы без знаний об UI; возврат на main только при обновлении представления.

70) Как мигрировать callback API на async безопасно?
- Оборачивать через `withCheckedThrowingContinuation`, обрабатывать cancel/timeout.

71) Какой минимальный набор правил для безопасного кода?
- Не блокировать main, изолировать общий стейт, ограничивать параллелизм, проверять отмену.

72) Когда OperationQueue избыточна?
- Если нет графа/зависимостей — предпочтительнее GCD или async/await.

73) Когда GCD избыточен?
- Когда нужен структурированный поток и отмена — берите Swift Concurrency.

74) Можно ли смешивать Combine и async?
- Да, но осознанно и локально на границах; избегайте «зоопарка» парадигм.

75) Как хранить долгоживущие фоновые задачи?
- В менеджере задач/сервисе, с возможностью отмены и мониторинга состояния.

76) Как организовать ретраи с джиттером?
- Экспоненциальный backoff + случайная составляющая, с верхними лимитами.

77) Как синхронизировать доступ из Objective‑C?
- NSLock/NSRecursiveLock/`@synchronized` или обёртка‑актор со Swift интерфейсом.

78) В чём преимущество акторов над локами?
- Меньше ошибок проектирования, проверка компилятором, читаемость и изоляция по умолчанию.

79) Как избежать долгих await внутри акторов?
- Вынести await‑операции за пределы критической секции или разбить метод.

80) Как планировать периодические фоновые задачи на iOS?
- BackgroundTasks API для системных окон, в приложении — timers/DispatchSource при активном процессе.

81) Что делать с массивом задач, если одна упала?
- При `withThrowingTaskGroup` остальные отменятся; обработать частичные результаты, логировать ошибки.

82) Как избежать двойной инициализации singleton?
- `static let shared` (потокобезопасно), избегайте собственных локов.

83) Как обеспечить атомарность счётчика?
- Актор, serial очередь или атомики (если доступны), избегайте `+=` без защиты.

84) Что выбрать для очереди БД‑операций?
- Serial очередь или актор над клиентом БД, чтобы исключить гонки и дедлоки.

85) Как организовать отмену всей пайплайн‑ветки?
- Структурированная конкурентность: отмена родительской задачи отменит детей.

86) Как диагностировать утечки задач?
- Логи создания/завершения, счётчики активных задач, профилирование по времени жизни.

87) Когда использовать `TaskGroup` вместо `async let`?
- Когда количество задач динамическое или требуется перебор результатов по мере готовности.

88) Что делать с неидемпотентными операциями при отмене?
- Проектируйте компенсации/rollback или делайте операции идемпотентными.

89) Как управлять приоритетами в Swift Concurrency?
- Указывать при создании Task; приоритет может эскалировать при ожидании.

90) Можно ли шарить URLSession между потоками?
- Да, он потокобезопасен; избегайте модификации shared состояния без защиты.

91) Как защитить кэш в памяти и на диске одновременно?
- Актор с внутренними очередями/операциями для диска; соблюдайте упорядочивание.

92) Как реализовать паузу/резюме фоновой работы?
- Через состояние задачи и кооперативные точки проверки; в Operations — свойство и пауза очереди.

93) Что делать с долгими синхронными библиотечными вызовами?
- Выносить в отдельную очередь/операцию, оборачивать в async через continuation.

94) Как защититься от «шторма» событий?
- Дебаунс/троттлинг, объединение обновлений, ограничение параллелизма.

95) Как отслеживать «висящие» задачи?
- Таймауты/варнинги по времени жизни, метрики, watchdog задачи.

96) Как сохранять консистентность кэша при ошибках?
- Записи атомарны, использовать временные файлы и переименования, в памяти — барьеры/акторы.

97) Как избежать блокировок при логировании?
- Асинхронная запись, буферизация, минимальные критические секции.

98) Как обрабатывать результаты по мере готовности?
- Итерация по TaskGroup, эмит результата сразу после завершения подзадачи.

99) Что делать с ресурсоёмкими изображениями?
- Декодирование/ресайз на фоне, кэш, отмена при скролле.

100) Как выстроить слои конкурентности в приложении?
- Слой сервисов (фон) → слой моделей/ViewModel (координация) → UI (main), чёткие границы.

101) Что важно знать про TLS и текущую задачу?
- Текущая задача хранится в TLS; при await контекст переносится корректно рантаймом.

102) Как тестировать отмену?
- Запускать задачу, вызывать `cancel()`, проверять cleanup и отсутствие побочных эффектов.

103) Как документировать конкурентность?
- Описывать правила изоляции, очереди, контракты отмены/ошибок, QoS, границы слоёв.

104) Какой минимальный набор практик для собеса?
- Actors для общего стейта, structured concurrency, проверки отмены, QoS, UI только на main.

105) Как распределять работу между CPU и I/O?
- CPU — ограничение по ядрам; I/O — по лимитам сервиса/соединений, с back-pressure.

106) Почему важно не блокировать executors?
- Блокировка снижает кооперативность, ухудшает latency и UX.

107) Как проектировать повторно используемые операции?
- Инкапсулировать зависимые шаги в Operation/акторах/сервисах с чёткими контрактами.

108) Что такое «горячие» и «холодные» источники событий?
- Горячие генерируют независимо от подписчиков; холодные — по запросу. Влияет на конкурентную обработку.

109) Как снизить накладные расходы синхронизации?
- Предпочитать неизменяемость, локальные копии, батчи, минимальные критические секции.

110) Как подготовиться к live‑кодингу по конкурентности?
- Отрепетировать шаблоны: TaskGroup, barrier‑кэш, AsyncOperation, семафор N, отменяемая загрузка.


